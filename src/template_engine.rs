use anyhow::{Context, Result};
use std::path::PathBuf;
use crate::ColorScheme;

pub struct TemplateEngine {
    templates_dir: PathBuf,
}

impl TemplateEngine {
    pub fn new() -> Result<Self> {
        let config_dir = dirs::config_dir()
            .context("Failed to get config directory")?
            .join("iro");
        let templates_dir = config_dir.join("templates");
        
        // Create templates directory if it doesn't exist
        std::fs::create_dir_all(&templates_dir)
            .context("Failed to create templates directory")?;
        
        Ok(Self { templates_dir })
    }

    pub fn render_template(&self, template_name: &str, color_scheme: &ColorScheme) -> Result<String> {
        let template_path = self.templates_dir.join(template_name);
        let mut rendered = std::fs::read_to_string(&template_path)
            .with_context(|| format!("Failed to read template: {}", template_name))?;

        // Simple template variable replacement
        rendered = rendered.replace("{{ background }}", &color_scheme.background);
        rendered = rendered.replace("{{ foreground }}", &color_scheme.foreground);
        rendered = rendered.replace("{{ accent }}", &color_scheme.accent);
        rendered = rendered.replace("{{ secondary }}", &color_scheme.secondary);
        rendered = rendered.replace("{{ surface }}", &color_scheme.surface);
        rendered = rendered.replace("{{ error }}", &color_scheme.error);

        // Individual colors - use direct indexing to avoid repeated lookups
        for i in 0..color_scheme.colors.len() {
            if let Some(color) = color_scheme.colors.get(i) {
                rendered = rendered.replace(&format!("{{{{ colors.{} }}}}", i), color);
            }
        }

        // Named colors for convenience - use array slicing to avoid repeated get calls
        let named_colors = [
            ("{{ red }}", 1),
            ("{{ green }}", 2),
            ("{{ yellow }}", 3),
            ("{{ blue }}", 4),
            ("{{ magenta }}", 5),
            ("{{ cyan }}", 6),
            ("{{ white }}", 7),
        ];

        for (name, idx) in &named_colors {
            if let Some(color) = color_scheme.colors.get(*idx) {
                rendered = rendered.replace(name, color);
            }
        }

        Ok(rendered)
    }
    

    pub fn create_default_templates(&self) -> Result<()> {
        self.create_waybar_template()?;
        self.create_kitty_template()?;
        self.create_shell_colors_template()?;
        Ok(())
    }

    fn create_waybar_template(&self) -> Result<()> {
        let template_path = self.templates_dir.join("waybar.css");
        if template_path.exists() {
            return Ok(()); // Don't overwrite existing templates
        }
        
        let template_content = r#"/* Dynamic Waybar Theme - Generated by iro */

* {
  font-family: "JetBrainsMono Nerd Font", "Monocraft", "Symbols Nerd Font Mono";
  font-size: 16px;
  font-weight: 500;
  border: none;
  min-height: 0;
  margin: 0;
  padding: 0;
}

/* Dynamic Color Variables */
@define-color red {{ red }};
@define-color blue {{ blue }};
@define-color yellow {{ yellow }};
@define-color magenta {{ magenta }};
@define-color accent {{ accent }};
@define-color secondary {{ secondary }};
@define-color text {{ foreground }};
@define-color surface {{ surface }};
@define-color base {{ background }};
@define-color error {{ error }};

/* Main Window */
window#waybar {
  background-color: transparent;
  transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
}

/* Base module styling */
.module {
  background: alpha(@base, 0.9);
  color: @text;
  margin: 2px 3px;
  padding: 6px 14px;
  border-radius: 15px;
  border: 2px solid transparent;
  transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
}

.module:hover {
  background: alpha(@accent, 0.2);
}

#custom-logo {
  background: @accent;
  color: @base;
  font-size: 20px;
  font-weight: bold;
  margin-left: 0;
  border-radius: 15px;
  min-width: 40px;
  padding: 0 3px 0 0px;
}

#workspaces {
  background: alpha(@base, 0.9);
  border-radius: 15px;
  padding: 0px 5px;
}

#workspaces button {
  background: transparent;
  color: @secondary;
  margin: -2px 0px;
  padding: 0;
  font-size: 18px;
  min-width: 28px;
  transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
  border-radius: 0;
  padding-right: 5px;
}

#workspaces button:hover,
#workspaces button.active {
  background: @accent;
  color: @base;
  font-weight: bold;
}

#workspaces button.urgent {
  background: @error;
  color: @base;
  animation: urgent 1s ease-in-out infinite;
  border-radius: 15px;
}

@keyframes urgent {
  from { opacity: 1; }
  to { opacity: 0.7; }
}

#window {
  background-color: alpha(@secondary, 0.25);
  color: @text;
  font-style: italic;
  border-radius: 15px;
  margin: 2px 6px;
  padding: 6px 16px;
}

#clock {
  background: alpha(@base, 0.9);
  color: @text;
  font-weight: 500;
  font-size: 14px;
  border-radius: 15px;
  padding: 6px 18px;
  margin: 2px 6px;
}

#clock:hover {
  background: alpha(@accent, 0.2);
}

#temperature,
#cpu,
#memory,
#pulseaudio,
#network,
#bluetooth,
#battery {
  color: @text;
}

#battery.charging {
  color: @yellow;
}

#battery.warning:not(.charging) {
  color: @yellow;
}

#battery.critical:not(.charging) {
  color: @error;
}

#custom-power {
  background: @error;
  color: @base;
  font-size: 14px;
  font-weight: bold;
  border-radius: 50%;
  margin-right: 0;
  min-width: 32px;
  padding: 0;
}
"#;
        
        std::fs::write(&template_path, template_content)
            .context("Failed to write waybar template")?;
        println!("  ✓ Created waybar template");
        Ok(())
    }

    fn create_kitty_template(&self) -> Result<()> {
        let template_path = self.templates_dir.join("kitty.conf");
        if template_path.exists() {
            return Ok(()); // Don't overwrite existing templates
        }
        
        let template_content = "# Dynamic Kitty Theme - Generated by iro

# Background and foreground
foreground            {{ foreground }}
background            {{ background }}
selection_foreground  {{ background }}
selection_background  {{ accent }}

# Cursor colors
cursor                {{ accent }}
cursor_text_color     {{ background }}

# Terminal colors (0-15)
color0   {{ colors.0 }}
color1   {{ colors.1 }}
color2   {{ colors.2 }}
color3   {{ colors.3 }}
color4   {{ colors.4 }}
color5   {{ colors.5 }}
color6   {{ colors.6 }}
color7   {{ colors.7 }}
color8   {{ colors.8 }}
color9   {{ colors.9 }}
color10  {{ colors.10 }}
color11  {{ colors.11 }}
color12  {{ colors.12 }}
color13  {{ colors.13 }}
color14  {{ colors.14 }}
color15  {{ colors.15 }}

# Tab colors
active_tab_foreground   {{ background }}
active_tab_background   {{ accent }}
inactive_tab_foreground {{ secondary }}
inactive_tab_background {{ background }}

# Window borders  
active_border_color   {{ accent }}
inactive_border_color {{ surface }}
bell_border_color     {{ error }}
";
        
        std::fs::write(&template_path, template_content)
            .context("Failed to write kitty template")?;
        println!("  ✓ Created kitty template");
        Ok(())
    }

    fn create_shell_colors_template(&self) -> Result<()> {
        let template_path = self.templates_dir.join("shell_colors.sh");
        if template_path.exists() {
            return Ok(()); // Don't overwrite existing templates
        }

        let template_content = r#"#!/bin/bash
# Dynamic shell color exports - Generated by iro
# Source this file in your .bashrc or .zshrc to apply colors to prompts

# Base16 color exports
export BASE16_COLOR_00="{{ colors.0 }}"
export BASE16_COLOR_01="{{ colors.1 }}"
export BASE16_COLOR_02="{{ colors.2 }}"
export BASE16_COLOR_03="{{ colors.3 }}"
export BASE16_COLOR_04="{{ colors.4 }}"
export BASE16_COLOR_05="{{ colors.5 }}"
export BASE16_COLOR_06="{{ colors.6 }}"
export BASE16_COLOR_07="{{ colors.7 }}"
export BASE16_COLOR_08="{{ colors.8 }}"
export BASE16_COLOR_09="{{ colors.9 }}"
export BASE16_COLOR_0A="{{ colors.10 }}"
export BASE16_COLOR_0B="{{ colors.11 }}"
export BASE16_COLOR_0C="{{ colors.12 }}"
export BASE16_COLOR_0D="{{ colors.13 }}"
export BASE16_COLOR_0E="{{ colors.14 }}"
export BASE16_COLOR_0F="{{ colors.15 }}"

# Spaceship prompt colors
export SPACESHIP_CHAR_COLOR="{{ accent }}"
export SPACESHIP_TIME_COLOR="{{ secondary }}"
export SPACESHIP_USER_COLOR="{{ colors.4 }}"
export SPACESHIP_HOST_COLOR="{{ colors.5 }}"
export SPACESHIP_DIR_COLOR="{{ colors.6 }}"
export SPACESHIP_GIT_BRANCH_COLOR="{{ colors.2 }}"
export SPACESHIP_GIT_STATUS_COLOR="{{ colors.3 }}"
export SPACESHIP_EXEC_TIME_COLOR="{{ colors.11 }}"
export SPACESHIP_EXIT_CODE_COLOR="{{ error }}"

# FZF colors
export FZF_DEFAULT_OPTS="--color=bg+:{{ surface }},bg:{{ background }},spinner:{{ accent }},hl:{{ colors.4 }},fg:{{ foreground }},header:{{ colors.4 }},info:{{ colors.3 }},pointer:{{ accent }},marker:{{ accent }},fg+:{{ foreground }},prompt:{{ colors.5 }},hl+:{{ colors.4 }}"
"#;

        std::fs::write(&template_path, template_content)
            .context("Failed to write shell_colors template")?;
        println!("  ✓ Created shell_colors template");
        Ok(())
    }
}
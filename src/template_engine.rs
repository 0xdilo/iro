use anyhow::{Context, Result};
use std::path::PathBuf;
use crate::ColorScheme;

pub struct TemplateEngine {
    templates_dir: PathBuf,
}

impl TemplateEngine {
    pub fn new() -> Result<Self> {
        let config_dir = dirs::config_dir()
            .context("Failed to get config directory")?
            .join("iro");
        let templates_dir = config_dir.join("templates");
        
        // Create templates directory if it doesn't exist
        std::fs::create_dir_all(&templates_dir)
            .context("Failed to create templates directory")?;
        
        Ok(Self { templates_dir })
    }

    pub fn render_template(&self, template_name: &str, color_scheme: &ColorScheme) -> Result<String> {
        let template_path = self.templates_dir.join(template_name);
        let template_content = std::fs::read_to_string(&template_path)
            .with_context(|| format!("Failed to read template: {}", template_name))?;
        
        let mut rendered = template_content;
        
        // Simple template variable replacement
        rendered = rendered.replace("{{ background }}", &color_scheme.background);
        rendered = rendered.replace("{{ foreground }}", &color_scheme.foreground);
        rendered = rendered.replace("{{ accent }}", &color_scheme.accent);
        rendered = rendered.replace("{{ secondary }}", &color_scheme.secondary);
        rendered = rendered.replace("{{ surface }}", &color_scheme.surface);
        rendered = rendered.replace("{{ error }}", &color_scheme.error);
        
        // Individual colors
        for (i, color) in color_scheme.colors.iter().enumerate() {
            rendered = rendered.replace(&format!("{{{{ colors.{} }}}}", i), color);
        }
        
        // Named colors for convenience
        if let Some(red) = color_scheme.colors.get(1) {
            rendered = rendered.replace("{{ red }}", red);
        }
        if let Some(green) = color_scheme.colors.get(2) {
            rendered = rendered.replace("{{ green }}", green);
        }
        if let Some(yellow) = color_scheme.colors.get(3) {
            rendered = rendered.replace("{{ yellow }}", yellow);
        }
        if let Some(blue) = color_scheme.colors.get(4) {
            rendered = rendered.replace("{{ blue }}", blue);
        }
        if let Some(magenta) = color_scheme.colors.get(5) {
            rendered = rendered.replace("{{ magenta }}", magenta);
        }
        if let Some(cyan) = color_scheme.colors.get(6) {
            rendered = rendered.replace("{{ cyan }}", cyan);
        }
        if let Some(white) = color_scheme.colors.get(7) {
            rendered = rendered.replace("{{ white }}", white);
        }
        
        // Handle hex color stripping for certain formats
        rendered = self.process_color_filters(&rendered);
        
        Ok(rendered)
    }
    
    fn process_color_filters(&self, content: &str) -> String {
        // Simple filter processing - just return as-is for now
        // The template syntax is simple enough that we don't need complex filtering
        content.to_string()
    }

    pub fn create_default_templates(&self) -> Result<()> {
        self.create_waybar_template()?;
        self.create_kitty_template()?;
        Ok(())
    }

    fn create_waybar_template(&self) -> Result<()> {
        let template_path = self.templates_dir.join("waybar.css");
        if template_path.exists() {
            return Ok(()); // Don't overwrite existing templates
        }
        
        let template_content = r#"/* Dynamic Waybar Theme - Generated by iro */

* {
  font-family: "JetBrainsMono Nerd Font", "Monocraft", "Symbols Nerd Font Mono";
  font-size: 16px;
  font-weight: 500;
  border: none;
  min-height: 0;
  margin: 0;
  padding: 0;
}

/* Dynamic Color Variables */
@define-color red {{ red }};
@define-color blue {{ blue }};
@define-color yellow {{ yellow }};
@define-color magenta {{ magenta }};
@define-color accent {{ accent }};
@define-color secondary {{ secondary }};
@define-color text {{ foreground }};
@define-color surface {{ surface }};
@define-color base {{ background }};
@define-color error {{ error }};

/* Main Window */
window#waybar {
  background-color: transparent;
  transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
}

/* Base module styling */
.module {
  background: alpha(@base, 0.9);
  color: @text;
  margin: 2px 3px;
  padding: 6px 14px;
  border-radius: 15px;
  border: 2px solid transparent;
  transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
}

.module:hover {
  background: alpha(@accent, 0.2);
}

#custom-logo {
  background: @accent;
  color: @base;
  font-size: 20px;
  font-weight: bold;
  margin-left: 0;
  border-radius: 15px;
  min-width: 40px;
  padding: 0 3px 0 0px;
}

#workspaces {
  background: alpha(@base, 0.9);
  border-radius: 15px;
  padding: 0px 5px;
}

#workspaces button {
  background: transparent;
  color: @secondary;
  margin: -2px 0px;
  padding: 0;
  font-size: 18px;
  min-width: 28px;
  transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
  border-radius: 0;
  padding-right: 5px;
}

#workspaces button:hover,
#workspaces button.active {
  background: @accent;
  color: @base;
  font-weight: bold;
}

#workspaces button.urgent {
  background: @error;
  color: @base;
  animation: urgent 1s ease-in-out infinite;
  border-radius: 15px;
}

@keyframes urgent {
  from { opacity: 1; }
  to { opacity: 0.7; }
}

#window {
  background-color: alpha(@secondary, 0.25);
  color: @text;
  font-style: italic;
  border-radius: 15px;
  margin: 2px 6px;
  padding: 6px 16px;
}

#clock {
  background: alpha(@base, 0.9);
  color: @text;
  font-weight: 500;
  font-size: 14px;
  border-radius: 15px;
  padding: 6px 18px;
  margin: 2px 6px;
}

#clock:hover {
  background: alpha(@accent, 0.2);
}

#temperature,
#cpu,
#memory,
#pulseaudio,
#network,
#bluetooth,
#battery {
  color: @text;
}

#battery.charging {
  color: @yellow;
}

#battery.warning:not(.charging) {
  color: @yellow;
}

#battery.critical:not(.charging) {
  color: @error;
}

#custom-power {
  background: @error;
  color: @base;
  font-size: 14px;
  font-weight: bold;
  border-radius: 50%;
  margin-right: 0;
  min-width: 32px;
  padding: 0;
}
"#;
        
        std::fs::write(&template_path, template_content)
            .context("Failed to write waybar template")?;
        println!("  ✓ Created waybar template");
        Ok(())
    }

    fn create_kitty_template(&self) -> Result<()> {
        let template_path = self.templates_dir.join("kitty.conf");
        if template_path.exists() {
            return Ok(()); // Don't overwrite existing templates
        }
        
        let template_content = "# Dynamic Kitty Theme - Generated by iro

# Background and foreground
foreground            {{ foreground }}
background            {{ background }}
selection_foreground  {{ background }}
selection_background  {{ accent }}

# Cursor colors
cursor                {{ accent }}
cursor_text_color     {{ background }}

# Terminal colors (0-15)
color0   {{ colors.0 }}
color1   {{ colors.1 }}
color2   {{ colors.2 }}
color3   {{ colors.3 }}
color4   {{ colors.4 }}
color5   {{ colors.5 }}
color6   {{ colors.6 }}
color7   {{ colors.7 }}
color8   {{ colors.8 }}
color9   {{ colors.9 }}
color10  {{ colors.10 }}
color11  {{ colors.11 }}
color12  {{ colors.12 }}
color13  {{ colors.13 }}
color14  {{ colors.14 }}
color15  {{ colors.15 }}

# Tab colors
active_tab_foreground   {{ background }}
active_tab_background   {{ accent }}
inactive_tab_foreground {{ secondary }}
inactive_tab_background {{ background }}

# Window borders  
active_border_color   {{ accent }}
inactive_border_color {{ surface }}
bell_border_color     {{ error }}
";
        
        std::fs::write(&template_path, template_content)
            .context("Failed to write kitty template")?;
        println!("  ✓ Created kitty template");
        Ok(())
    }
}
use crate::ColorScheme;
use anyhow::{Context, Result};
use std::path::PathBuf;

pub struct TemplateEngine {
    templates_dir: PathBuf,
}

impl TemplateEngine {
    pub fn new() -> Result<Self> {
        let config_dir = dirs::config_dir()
            .context("Failed to get config directory")?
            .join("iro");
        let templates_dir = config_dir.join("templates");

        // Create templates directory if it doesn't exist
        std::fs::create_dir_all(&templates_dir).context("Failed to create templates directory")?;

        Ok(Self { templates_dir })
    }

    pub fn render_template(
        &self,
        template_name: &str,
        color_scheme: &ColorScheme,
    ) -> Result<String> {
        let template_path = self.templates_dir.join(template_name);
        let mut rendered = std::fs::read_to_string(&template_path)
            .with_context(|| format!("Failed to read template: {}", template_name))?;

        // Simple template variable replacement
        rendered = rendered.replace("{{ background }}", &color_scheme.background);
        rendered = rendered.replace("{{ foreground }}", &color_scheme.foreground);
        rendered = rendered.replace("{{ accent }}", &color_scheme.accent);
        rendered = rendered.replace("{{ secondary }}", &color_scheme.secondary);
        rendered = rendered.replace("{{ surface }}", &color_scheme.surface);
        rendered = rendered.replace("{{ error }}", &color_scheme.error);

        // Individual colors - use direct indexing to avoid repeated lookups
        for i in 0..color_scheme.colors.len() {
            if let Some(color) = color_scheme.colors.get(i) {
                rendered = rendered.replace(&format!("{{{{ colors.{} }}}}", i), color);
            }
        }

        // Named colors for convenience - matches color_extractor.rs hue order:
        // 1=red(345-30°), 2=yellow(30-90°), 3=green(90-150°), 4=cyan(150-210°), 5=blue(210-270°), 6=magenta(270-345°)
        let named_colors = [
            ("{{ red }}", 1),
            ("{{ yellow }}", 2),
            ("{{ green }}", 3),
            ("{{ cyan }}", 4),
            ("{{ blue }}", 5),
            ("{{ magenta }}", 6),
            ("{{ white }}", 7),
        ];

        for (name, idx) in &named_colors {
            if let Some(color) = color_scheme.colors.get(*idx) {
                rendered = rendered.replace(name, color);
            }
        }

        Ok(rendered)
    }

    pub fn create_default_templates(&self) -> Result<()> {
        self.create_waybar_template()?;
        self.create_kitty_template()?;
        self.create_shell_colors_template()?;
        self.create_rofi_template()?;
        self.create_quickshell_template()?;
        Ok(())
    }

    fn create_waybar_template(&self) -> Result<()> {
        let template_path = self.templates_dir.join("waybar.css");
        if template_path.exists() {
            return Ok(()); // Don't overwrite existing templates
        }

        let template_content = r#"/* Dynamic Waybar Theme - Generated by iro */

* {
  font-family: "JetBrainsMono Nerd Font", "Monocraft", "Symbols Nerd Font Mono";
  font-size: 16px;
  font-weight: 500;
  border: none;
  min-height: 0;
  margin: 0;
  padding: 0;
}

/* Dynamic Color Variables */
@define-color red {{ red }};
@define-color blue {{ blue }};
@define-color yellow {{ yellow }};
@define-color magenta {{ magenta }};
@define-color accent {{ accent }};
@define-color secondary {{ secondary }};
@define-color text {{ foreground }};
@define-color surface {{ surface }};
@define-color base {{ background }};
@define-color error {{ error }};

/* Main Window */
window#waybar {
  background-color: transparent;
  transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
}

/* Base module styling */
.module {
  background: alpha(@base, 0.9);
  color: @text;
  margin: 2px 3px;
  padding: 6px 14px;
  border-radius: 15px;
  border: 2px solid transparent;
  transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
}

.module:hover {
  background: alpha(@accent, 0.2);
}

#custom-logo {
  background: @accent;
  color: @base;
  font-size: 20px;
  font-weight: bold;
  margin-left: 0;
  border-radius: 15px;
  min-width: 40px;
  padding: 0 3px 0 0px;
}

#workspaces {
  background: alpha(@base, 0.9);
  border-radius: 15px;
  padding: 0px 5px;
}

#workspaces button {
  background: transparent;
  color: @secondary;
  margin: -2px 0px;
  padding: 0;
  font-size: 18px;
  min-width: 28px;
  transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
  border-radius: 0;
  padding-right: 5px;
}

#workspaces button:hover,
#workspaces button.active {
  background: @accent;
  color: @base;
  font-weight: bold;
}

#workspaces button.urgent {
  background: @error;
  color: @base;
  animation: urgent 1s ease-in-out infinite;
  border-radius: 15px;
}

@keyframes urgent {
  from { opacity: 1; }
  to { opacity: 0.7; }
}

#window {
  background-color: alpha(@secondary, 0.25);
  color: @text;
  font-style: italic;
  border-radius: 15px;
  margin: 2px 6px;
  padding: 6px 16px;
}

#clock {
  background: alpha(@base, 0.9);
  color: @text;
  font-weight: 500;
  font-size: 14px;
  border-radius: 15px;
  padding: 6px 18px;
  margin: 2px 6px;
}

#clock:hover {
  background: alpha(@accent, 0.2);
}

#temperature,
#cpu,
#memory,
#pulseaudio,
#network,
#bluetooth,
#battery {
  color: @text;
}

#battery.charging {
  color: @yellow;
}

#battery.warning:not(.charging) {
  color: @yellow;
}

#battery.critical:not(.charging) {
  color: @error;
}

#custom-power {
  background: @error;
  color: @base;
  font-size: 14px;
  font-weight: bold;
  border-radius: 50%;
  margin-right: 0;
  min-width: 32px;
  padding: 0;
}
"#;

        std::fs::write(&template_path, template_content)
            .context("Failed to write waybar template")?;
        println!("  ✓ Created waybar template");
        Ok(())
    }

    fn create_kitty_template(&self) -> Result<()> {
        let template_path = self.templates_dir.join("kitty.conf");
        if template_path.exists() {
            return Ok(()); // Don't overwrite existing templates
        }

        let template_content = "# Dynamic Kitty Theme - Generated by iro

# Background and foreground
foreground            {{ foreground }}
background            {{ background }}
selection_foreground  {{ background }}
selection_background  {{ accent }}

# Cursor colors
cursor                {{ accent }}
cursor_text_color     {{ background }}

# Terminal colors (0-15)
color0   {{ colors.0 }}
color1   {{ colors.1 }}
color2   {{ colors.2 }}
color3   {{ colors.3 }}
color4   {{ colors.4 }}
color5   {{ colors.5 }}
color6   {{ colors.6 }}
color7   {{ colors.7 }}
color8   {{ colors.8 }}
color9   {{ colors.9 }}
color10  {{ colors.10 }}
color11  {{ colors.11 }}
color12  {{ colors.12 }}
color13  {{ colors.13 }}
color14  {{ colors.14 }}
color15  {{ colors.15 }}

# Tab colors
active_tab_foreground   {{ background }}
active_tab_background   {{ accent }}
inactive_tab_foreground {{ secondary }}
inactive_tab_background {{ background }}

# Window borders  
active_border_color   {{ accent }}
inactive_border_color {{ surface }}
bell_border_color     {{ error }}
";

        std::fs::write(&template_path, template_content)
            .context("Failed to write kitty template")?;
        println!("  ✓ Created kitty template");
        Ok(())
    }

    fn create_shell_colors_template(&self) -> Result<()> {
        let template_path = self.templates_dir.join("shell_colors.sh");
        if template_path.exists() {
            return Ok(()); // Don't overwrite existing templates
        }

        let template_content = r#"#!/bin/bash
# Dynamic shell color exports - Generated by iro
# Source this file in your .bashrc or .zshrc to apply colors to prompts

# Base16 color exports
export BASE16_COLOR_00="{{ colors.0 }}"
export BASE16_COLOR_01="{{ colors.1 }}"
export BASE16_COLOR_02="{{ colors.2 }}"
export BASE16_COLOR_03="{{ colors.3 }}"
export BASE16_COLOR_04="{{ colors.4 }}"
export BASE16_COLOR_05="{{ colors.5 }}"
export BASE16_COLOR_06="{{ colors.6 }}"
export BASE16_COLOR_07="{{ colors.7 }}"
export BASE16_COLOR_08="{{ colors.8 }}"
export BASE16_COLOR_09="{{ colors.9 }}"
export BASE16_COLOR_0A="{{ colors.10 }}"
export BASE16_COLOR_0B="{{ colors.11 }}"
export BASE16_COLOR_0C="{{ colors.12 }}"
export BASE16_COLOR_0D="{{ colors.13 }}"
export BASE16_COLOR_0E="{{ colors.14 }}"
export BASE16_COLOR_0F="{{ colors.15 }}"

# Spaceship prompt colors
export SPACESHIP_CHAR_COLOR="{{ accent }}"
export SPACESHIP_TIME_COLOR="{{ secondary }}"
export SPACESHIP_USER_COLOR="{{ colors.4 }}"
export SPACESHIP_HOST_COLOR="{{ colors.5 }}"
export SPACESHIP_DIR_COLOR="{{ colors.6 }}"
export SPACESHIP_GIT_BRANCH_COLOR="{{ colors.2 }}"
export SPACESHIP_GIT_STATUS_COLOR="{{ colors.3 }}"
export SPACESHIP_EXEC_TIME_COLOR="{{ colors.11 }}"
export SPACESHIP_EXIT_CODE_COLOR="{{ error }}"

# FZF colors
export FZF_DEFAULT_OPTS="--color=bg+:{{ surface }},bg:{{ background }},spinner:{{ accent }},hl:{{ colors.4 }},fg:{{ foreground }},header:{{ colors.4 }},info:{{ colors.3 }},pointer:{{ accent }},marker:{{ accent }},fg+:{{ foreground }},prompt:{{ colors.5 }},hl+:{{ colors.4 }}"
"#;

        std::fs::write(&template_path, template_content)
            .context("Failed to write shell_colors template")?;
        println!("  ✓ Created shell_colors template");
        Ok(())
    }

    fn create_rofi_template(&self) -> Result<()> {
        let template_path = self.templates_dir.join("rofi.rasi");
        if template_path.exists() {
            return Ok(()); // Don't overwrite existing templates
        }

        let template_content = r#"/* ═══════════════════════════════════════════════════════════════════ */
/* DYNAMIC COLOR SCHEME - Generated by iro                              */
/* ═══════════════════════════════════════════════════════════════════ */

* {
    /* Main colors */
    red:       {{ colors.1 }};
    blue:      {{ colors.4 }};
    yellow:    {{ colors.3 }};
    magenta:   {{ colors.5 }};
    green:     {{ colors.2 }};
    cyan:      {{ colors.6 }};

    /* Text colors */
    text:      {{ foreground }};
    overlay1:  {{ secondary }};

    /* Surface colors */
    surface2:  {{ colors.8 }};
    surface0:  {{ surface }};
    base:      {{ background }};
    mantle:    {{ colors.0 }};
    crust:     {{ background }};

    /* Semantic colors */
    background:           @crust;
    background-alt:       @mantle;
    background-bar:       @surface0;
    foreground:           @text;
    border:               {{ accent }};
    border-alt:           @blue;
    selected:             @surface0;
    selected-active:      {{ accent }};
    urgent:               @red;
    urgent-selected:      {{ error }};

    /* Spacing and sizing */
    margin:     0px;
    padding:    0px;
    spacing:    0px;
}
"#;

        std::fs::write(&template_path, template_content)
            .context("Failed to write rofi template")?;
        println!("  ✓ Created rofi template");
        Ok(())
    }

    fn create_quickshell_template(&self) -> Result<()> {
        let template_path = self.templates_dir.join("quickshell-theme.qml");
        if template_path.exists() {
            return Ok(()); // Don't overwrite existing templates
        }

        let template_content = r#"pragma Singleton
import QtQuick

QtObject {
    readonly property color background: "{{ background }}"
    readonly property color surface: "{{ surface }}"
    readonly property color surfaceHigh: Qt.lighter(surface, 1.15)
    readonly property color foreground: "{{ foreground }}"
    readonly property color muted: "{{ colors.8 }}"

    readonly property color accent: "{{ accent }}"
    readonly property color secondary: "{{ secondary }}"

    readonly property color red: "{{ red }}"
    readonly property color yellow: "{{ yellow }}"
    readonly property color green: "{{ green }}"
    readonly property color cyan: "{{ cyan }}"
    readonly property color blue: "{{ blue }}"
    readonly property color magenta: "{{ magenta }}"
    readonly property color pink: "{{ magenta }}"
    readonly property color error: "{{ error }}"
    readonly property color success: "{{ green }}"

    readonly property color icon: foreground
    readonly property color iconHover: accent

    readonly property color bgAlpha90: Qt.rgba(background.r, background.g, background.b, 0.94)
    readonly property color bgAlpha80: Qt.rgba(background.r, background.g, background.b, 0.88)
    readonly property color bgAlpha50: Qt.rgba(0, 0, 0, 0.5)

    readonly property color border: Qt.rgba(foreground.r, foreground.g, foreground.b, 0.08)
    readonly property color borderLight: Qt.rgba(foreground.r, foreground.g, foreground.b, 0.04)
    readonly property color glow: Qt.rgba(accent.r, accent.g, accent.b, 0.25)

    readonly property string font: "JetBrainsMono Nerd Font"
    readonly property string fontFamily: "JetBrainsMono Nerd Font"
}
"#;

        std::fs::write(&template_path, template_content)
            .context("Failed to write quickshell template")?;
        println!("  ✓ Created quickshell template");
        Ok(())
    }
}
